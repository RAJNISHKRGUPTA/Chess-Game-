<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Online</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow-y: hidden; /* Prevent scrolling of the whole page */
        }
        /* Chessboard square aspect ratio */
        .square {
            position: relative;
            width: 100%;
            padding-bottom: 100%;
        }
        .square-content {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .chess-piece {
            font-size: clamp(20px, 6vmin, 50px);
            cursor: grab;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .valid-move-indicator::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 35%;
            height: 35%;
            background-color: rgba(34, 197, 94, 0.5); /* Green with transparency */
            border-radius: 50%;
            pointer-events: none;
        }
        .capture-move-indicator::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 4px solid rgba(239, 68, 68, 0.5); /* Red with transparency */
            border-radius: 12%;
            box-sizing: border-box;
            pointer-events: none;
        }
        .selected {
            background-color: rgba(250, 204, 21, 0.6) !important; /* Yellow */
        }
        .in-check {
            background-color: rgba(239, 68, 68, 0.5) !important; /* Red */
        }
        /* Custom scrollbar for the feature panel */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #475569;
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800">
    <div class="flex flex-col lg:flex-row h-screen">
        
        <!-- Game Section -->
        <main class="w-full lg:w-2/3 xl:w-3/5 h-full flex flex-col items-center justify-center p-4 bg-slate-200">
            <div id="game-container" class="w-full max-w-[70vh] aspect-square flex flex-col shadow-2xl rounded-lg">
                <!-- Status Bar -->
                <div id="status-bar" class="bg-slate-800 text-white p-3 rounded-t-lg flex justify-between items-center">
                    <h1 class="text-xl font-bold">Chess Master</h1>
                    <div id="status" class="text-lg font-semibold">White's Turn</div>
                </div>

                <!-- Chessboard -->
                <div id="chessboard" class="grid grid-cols-8 grid-rows-8 w-full aspect-square bg-white">
                    <!-- Squares will be generated by JavaScript -->
                </div>

                <!-- Controls -->
                <div id="controls" class="bg-slate-800 p-3 rounded-b-lg flex justify-center items-center space-x-4">
                    <button id="new-game-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200">New Game</button>
                </div>
            </div>
        </main>

        <!-- Feature/Info Section -->
        <aside class="w-full lg:w-1/3 xl:w-2/5 h-screen bg-white p-8 overflow-y-auto custom-scrollbar">
            <div class="max-w-2xl mx-auto">
                <h2 class="text-3xl font-bold mb-2">Play Chess Online</h2>
                <p class="text-slate-600 mb-6">Join over 200 million players from around the world!</p>
                
                <p class="mb-4">Chess, ajedrez, xadrez, satran√ß, scacchi, schach, »ôah, ≈°achy, ≈üahmat‚Ä¶ no matter the language, no matter the name, it¬¥s known as the best strategy game in the world.</p>

                <p class="mb-6">Enjoy free unlimited 3d chess games and improve your chess rating with 500,000+ tactics puzzles, more than 20 million chess games a day, interactive lessons and videos, and over 100 powerful computer opponents. Unlock your inner chess master today!</p>

                <div class="space-y-6">
                    <div>
                        <h3 class="text-xl font-bold mb-3">‚ôüÔ∏è PLAY CHESS ONLINE FOR FREE:</h3>
                        <ul class="list-disc list-inside text-slate-700 space-y-1">
                            <li>2 Player chess mode completely free to enjoy with your friends</li>
                            <li>Meet new friends and chat while you play</li>
                            <li>Join tournaments with thousands of other players online</li>
                            <li>Play games in real-time from one minute per game to 30 minutes or longer</li>
                            <li>Play daily correspondence online chess for low-pressure games</li>
                            <li>Try exciting chess variants: chess960, blitz, puzzle rush, bullet, and more</li>
                        </ul>
                    </div>

                    <div>
                        <h3 class="text-xl font-bold mb-3">üß© CHESS TACTICS & CHESS PUZZLES:</h3>
                        <ul class="list-disc list-inside text-slate-700 space-y-1">
                            <li>Enjoy 500,000+ unique puzzles</li>
                            <li>Rated mode automatically adjusts to your skill level</li>
                            <li>Race the clock to beat your high score in Puzzle Rush</li>
                            <li>Practice puzzles with specific themes in learning mode</li>
                        </ul>
                    </div>

                    <div>
                        <h3 class="text-xl font-bold mb-3">üìö CHESS LESSONS:</h3>
                         <ul class="list-disc list-inside text-slate-700 space-y-1">
                            <li>Hundreds of quality chess lessons and videos made by masters</li>
                            <li>Interactive tutorials with tips and recommendations</li>
                            <li>Learn all rules and strategies in a step-by-step plan</li>
                        </ul>
                    </div>

                    <div>
                        <h3 class="text-xl font-bold mb-3">üìü PLAY CHESS ONLINE AGAINST THE COMPUTER:</h3>
                        <ul class="list-disc list-inside text-slate-700 space-y-1">
                            <li>Choose the level of computer opponent you want to play</li>
                            <li>Analyze your games to see where you went wrong</li>
                            <li>See how high you can go!</li>
                        </ul>
                    </div>
                </div>
            </div>
        </aside>

    </div>

    <!-- Start Game Modal -->
    <div id="start-game-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
        <div class="bg-white rounded-lg shadow-2xl p-8 text-center">
            <h2 class="text-4xl font-bold mb-4">Chess Master</h2>
            <p class="text-xl text-slate-600 mb-8">Ready to play?</p>
            <button id="start-game-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg text-xl transition-colors duration-200">Start Game</button>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="fixed inset-0 bg-black bg-opacity-60 hidden items-center justify-center z-50">
        <div class="bg-white rounded-lg shadow-2xl p-8 text-center animate-pulse">
            <h2 id="modal-title" class="text-3xl font-bold mb-4">Game Over</h2>
            <p id="modal-message" class="text-xl mb-6">White wins by Checkmate!</p>
            <button id="modal-new-game-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-colors duration-200">Play Again</button>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const chessboard = document.getElementById('chessboard');
            const statusDisplay = document.getElementById('status');
            const newGameBtn = document.getElementById('new-game-btn');
            const gameOverModal = document.getElementById('game-over-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalMessage = document.getElementById('modal-message');
            const modalNewGameBtn = document.getElementById('modal-new-game-btn');
            const startGameModal = document.getElementById('start-game-modal');
            const startGameBtn = document.getElementById('start-game-btn');

            // Unicode pieces
            const PIECES = {
                'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
                'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôüÔ∏é'
            };

            let boardState;
            let currentPlayer;
            let selectedPiece = null;
            let validMoves = [];
            let kingInCheck = null;

            function initializeGame() {
                // Initial board setup
                boardState = [
                    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'],
                ];
                currentPlayer = 'white';
                selectedPiece = null;
                validMoves = [];
                kingInCheck = null;
                updateStatus();
                renderBoard();
            }
            
            function createBoardDOM() {
                chessboard.innerHTML = '';
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.classList.add('square');
                        const isLight = (row + col) % 2 === 0;
                        square.classList.add(isLight ? 'bg-amber-100' : 'bg-amber-600');

                        const content = document.createElement('div');
                        content.classList.add('square-content');
                        content.dataset.row = row;
                        content.dataset.col = col;
                        
                        square.appendChild(content);
                        chessboard.appendChild(square);

                        content.addEventListener('click', () => onSquareClick(row, col));
                    }
                }
            }

            function renderBoard() {
                const squares = document.querySelectorAll('.square-content');
                squares.forEach(square => {
                    const row = parseInt(square.dataset.row);
                    const col = parseInt(square.dataset.col);
                    const piece = boardState[row][col];

                    square.innerHTML = ''; // Clear previous piece
                    square.classList.remove('selected', 'in-check', 'valid-move-indicator', 'capture-move-indicator');

                    if (piece) {
                        const pieceElement = document.createElement('span');
                        pieceElement.classList.add('chess-piece');
                        pieceElement.textContent = PIECES[piece];
                        pieceElement.style.color = (piece === piece.toUpperCase()) ? '#FFFFFF' : '#000000';
                        square.appendChild(pieceElement);
                    }
                    
                    if (kingInCheck && piece && piece.toLowerCase() === 'k' && isPieceWhite(piece) === (kingInCheck === 'white')) {
                         square.classList.add('in-check');
                    }
                });
                
                if (selectedPiece) {
                    const selectedSquare = document.querySelector(`[data-row='${selectedPiece.row}'][data-col='${selectedPiece.col}']`);
                    if (selectedSquare) {
                        selectedSquare.classList.add('selected');
                    }
                    highlightValidMoves();
                }
            }

            function onSquareClick(row, col) {
                const piece = boardState[row][col];

                if (selectedPiece) {
                    const isValidMove = validMoves.some(move => move.row === row && move.col === col);
                    if (isValidMove) {
                        makeMove(selectedPiece.row, selectedPiece.col, row, col);
                    } else {
                        deselectPiece();
                        // If clicking another of your own pieces, select it
                        if (piece && isPieceWhite(piece) === (currentPlayer === 'white')) {
                            selectPiece(row, col);
                        }
                    }
                } else if (piece && isPieceWhite(piece) === (currentPlayer === 'white')) {
                    selectPiece(row, col);
                }
            }

            function selectPiece(row, col) {
                selectedPiece = { piece: boardState[row][col], row, col };
                validMoves = getValidMoves(selectedPiece.piece, row, col);
                renderBoard();
            }

            function deselectPiece() {
                selectedPiece = null;
                validMoves = [];
                renderBoard();
            }
            
            function highlightValidMoves() {
                validMoves.forEach(move => {
                    const square = document.querySelector(`[data-row='${move.row}'][data-col='${move.col}']`);
                    if(square) {
                        if (boardState[move.row][move.col] !== null) {
                             square.classList.add('capture-move-indicator');
                        } else {
                             square.classList.add('valid-move-indicator');
                        }
                    }
                });
            }

            function makeMove(fromRow, fromCol, toRow, toCol) {
                const piece = boardState[fromRow][fromCol];
                boardState[toRow][toCol] = piece;
                boardState[fromRow][fromCol] = null;
                
                // Pawn Promotion
                if (piece.toLowerCase() === 'p' && (toRow === 0 || toRow === 7)) {
                    boardState[toRow][toCol] = isPieceWhite(piece) ? 'Q' : 'q';
                }

                currentPlayer = (currentPlayer === 'white') ? 'black' : 'white';
                kingInCheck = isKingInCheck(currentPlayer) ? currentPlayer : null;
                deselectPiece(); // This calls renderBoard
                updateStatus();
                checkGameOver();
            }
            
            function isPieceWhite(piece) {
                return piece === piece.toUpperCase();
            }
            
            function updateStatus() {
                let statusText = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s Turn`;
                if(kingInCheck) {
                    statusText += ` - Check!`;
                }
                statusDisplay.textContent = statusText;
            }

            function checkGameOver() {
                const hasMoves = hasAnyValidMoves(currentPlayer);
                if (!hasMoves) {
                    if (kingInCheck) {
                        const winner = currentPlayer === 'white' ? 'Black' : 'White';
                        showGameOverModal(`${winner} wins by Checkmate!`);
                    } else {
                        showGameOverModal("Stalemate! It's a draw.");
                    }
                }
            }
            
            function hasAnyValidMoves(playerColor) {
                 for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = boardState[r][c];
                        if (piece && isPieceWhite(piece) === (playerColor === 'white')) {
                            if (getValidMoves(piece, r, c).length > 0) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            function showGameOverModal(message) {
                modalMessage.textContent = message;
                gameOverModal.classList.remove('hidden');
                gameOverModal.classList.add('flex');
            }
            
            function hideGameOverModal() {
                 gameOverModal.classList.add('hidden');
                 gameOverModal.classList.remove('flex');
            }
            
            newGameBtn.addEventListener('click', () => {
                hideGameOverModal();
                initializeGame();
            });
            modalNewGameBtn.addEventListener('click', () => {
                hideGameOverModal();
                initializeGame();
            });

            startGameBtn.addEventListener('click', () => {
                startGameModal.classList.add('hidden');
                startGameModal.classList.remove('flex');
                initializeGame();
            });

            // --- Chess Logic ---
            function getValidMoves(piece, row, col) {
                const moves = [];
                const pieceType = piece.toLowerCase();
                
                // Generic move generation
                if (pieceType === 'p') getPawnMoves(piece, row, col, moves);
                if (pieceType === 'r') getSlidingMoves(piece, row, col, [[0,1], [0,-1], [1,0], [-1,0]], moves);
                if (pieceType === 'b') getSlidingMoves(piece, row, col, [[1,1], [1,-1], [-1,1], [-1,-1]], moves);
                if (pieceType === 'q') getSlidingMoves(piece, row, col, [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]], moves);
                if (pieceType === 'k') getKingMoves(piece, row, col, moves);
                if (pieceType === 'n') getKnightMoves(piece, row, col, moves);

                // Filter out moves that would leave the king in check
                const playerColor = isPieceWhite(piece) ? 'white' : 'black';
                return moves.filter(move => !moveResultsInCheck(playerColor, row, col, move.row, move.col));
            }
            
            function getPawnMoves(piece, row, col, moves) {
                const direction = isPieceWhite(piece) ? -1 : 1;
                const startRow = isPieceWhite(piece) ? 6 : 1;

                // Forward 1
                if (row + direction >= 0 && row + direction < 8 && !boardState[row + direction][col]) {
                    moves.push({row: row + direction, col});
                    // Forward 2 from start
                    if (row === startRow && !boardState[row + 2 * direction][col]) {
                        moves.push({row: row + 2 * direction, col});
                    }
                }
                // Captures
                [-1, 1].forEach(dCol => {
                    if (col + dCol >= 0 && col + dCol < 8) {
                        const target = boardState[row + direction]?.[col + dCol];
                        if (target && isPieceWhite(target) !== isPieceWhite(piece)) {
                            moves.push({row: row + direction, col: col + dCol});
                        }
                    }
                });
            }

            function getSlidingMoves(piece, row, col, directions, moves) {
                directions.forEach(([dr, dc]) => {
                    for (let i = 1; i < 8; i++) {
                        const newRow = row + i * dr;
                        const newCol = col + i * dc;
                        if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                        const target = boardState[newRow][newCol];
                        if (!target) {
                            moves.push({row: newRow, col: newCol});
                        } else {
                            if (isPieceWhite(target) !== isPieceWhite(piece)) {
                                moves.push({row: newRow, col: newCol});
                            }
                            break;
                        }
                    }
                });
            }

            function getKingMoves(piece, row, col, moves) {
                 for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            const target = boardState[newRow][newCol];
                            if (!target || isPieceWhite(target) !== isPieceWhite(piece)) {
                                moves.push({row: newRow, col: newCol});
                            }
                        }
                    }
                }
            }

            function getKnightMoves(piece, row, col, moves) {
                const knightMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
                knightMoves.forEach(([dr, dc]) => {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                        const target = boardState[newRow][newCol];
                        if (!target || isPieceWhite(target) !== isPieceWhite(piece)) {
                            moves.push({row: newRow, col: newCol});
                        }
                    }
                });
            }
            
            function moveResultsInCheck(playerColor, fromRow, fromCol, toRow, toCol) {
                // Temporarily make the move
                const originalPiece = boardState[toRow][toCol];
                boardState[toRow][toCol] = boardState[fromRow][fromCol];
                boardState[fromRow][fromCol] = null;
                
                const inCheck = isKingInCheck(playerColor);

                // Undo the temporary move
                boardState[fromRow][fromCol] = boardState[toRow][toCol];
                boardState[toRow][toCol] = originalPiece;
                
                return inCheck;
            }
            
            function isKingInCheck(playerColor) {
                const kingPos = findKing(playerColor);
                if (!kingPos) return false;
                
                const opponentColor = playerColor === 'white' ? 'black' : 'white';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = boardState[r][c];
                        if (piece && isPieceWhite(piece) === (opponentColor === 'white')) {
                           const moves = getRawMoves(piece, r, c);
                           if (moves.some(move => move.row === kingPos.row && move.col === kingPos.col)) {
                               return true;
                           }
                        }
                    }
                }
                return false;
            }
            
            function findKing(playerColor) {
                const kingChar = playerColor === 'white' ? 'K' : 'k';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (boardState[r][c] === kingChar) {
                            return {row: r, col: c};
                        }
                    }
                }
                return null;
            }
            
            // Gets moves without checking for check - used for check detection
            function getRawMoves(piece, row, col) {
                const moves = [];
                const pieceType = piece.toLowerCase();
                if (pieceType === 'p') getPawnMoves(piece, row, col, moves);
                if (pieceType === 'r') getSlidingMoves(piece, row, col, [[0,1], [0,-1], [1,0], [-1,0]], moves);
                if (pieceType === 'b') getSlidingMoves(piece, row, col, [[1,1], [1,-1], [-1,1], [-1,-1]], moves);
                if (pieceType === 'q') getSlidingMoves(piece, row, col, [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]], moves);
                if (pieceType === 'k') getKingMoves(piece, row, col, moves);
                if (pieceType === 'n') getKnightMoves(piece, row, col, moves);
                return moves;
            }

            // Initial setup
            createBoardDOM();
            // initializeGame(); // This is now triggered by the start button
        });
    </script>
</body>
</html>

